("undefined"!=typeof self?self:this.webpackJsonpfluro="undefined"!=typeof self?self:this.webpackJsonpfluro||[]).push([[2],{137:function(t,e){function n(t,e){if(t=t.replace(/\s+/g,""),e=e.replace(/\s+/g,""),!t.length&&!e.length)return 1;if(!t.length||!e.length)return 0;if(t===e)return 1;if(1===t.length&&1===e.length)return 0;if(t.length<2||e.length<2)return 0;let n=new Map;for(let e=0;e<t.length-1;e++){const r=t.substr(e,2),s=n.has(r)?n.get(r)+1:1;n.set(r,s)}let r=0;for(let t=0;t<e.length-1;t++){const s=e.substr(t,2),l=n.has(s)?n.get(s):0;l>0&&(n.set(s,l-1),r++)}return 2*r/(t.length+e.length-2)}t.exports={compareTwoStrings:n,findBestMatch:function(t,e){if(!function(t,e){return"string"==typeof t&&!!Array.isArray(e)&&!!e.length&&!e.find(t=>"string"!=typeof t)}(t,e))throw new Error("Bad arguments: First argument should be a string, second should be an array of strings");const r=[];let s=0;for(let l=0;l<e.length;l++){const g=e[l],o=n(t,g);r.push({target:g,rating:o}),o>r[s].rating&&(s=l)}const l=r[s];return{ratings:r,bestMatch:l,bestMatchIndex:s}}}}}]);